<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    시간 복잡도 
    시간 복잡도는 알고리즘의 성능을 나타내는 척도 
    특정한 크기의 입력에 대해서 알고리즘의 수행시간 분석 (수치가 크다) 
    
    동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 우수하다.


    시간복잡도 좋음 순  
    O(1) 상수시간 constant time 
    O(logN) 로그시간 log time 
    O(N) 선형 시간 ninear time
    O(NlogN) 로그 선형 시간 log-linear time
    O(N²) 이차 시간 quadratic time 
    O(N³) 삼차시간 cubic time 
    O(2^n) 지수 시간 exponential time



    알고리즘 설계 팁 1 
    일반적으로 CPI기반의 컴터가 js 기준 1억번의 연산을 처리하기위해 1~5초 소요 
    O(N²) 알고리즘 설계한 경우 N값이 5000이 넘는다면 대략 100초정도 걸림 
    그럼 O(N²)은 적합하지 않음

    "요구사항에 따라 적절한 알고리즘 설계하기"
    시간제한(수행 시간 요구사항)을 먼저 확인해서 
    시간제한이 1초인 경우 N의 범위가 
    1. 500인 경우 : O(N³) 설계 
    2. 2,000인 경우 :  O(N²) 설계 
    3. 100,000인 경우 : O(NlogN) 설계
    4. 10,000,000 인경우 O(N) 설계


    <style>
        li.on {background-color: red;}
    </style>

    <section>
        <ul>
            <li>1</li>
            <li>1</li>
            <li>1</li>
            <li>1</li>
            <li>1</li>
            <li>1</li>
            <li>1</li>
            <li>1</li>
        </ul>
    </section>


    <script>


        const ul = document.querySelector('ul');
        const lis = document.querySelectorAll('li')

        console.log(ul, lis)

        
        for(let i = 0; i < lis.length; i++) {
            // lis[i].classList.remove('on')
            lis[i].addEventListener('click', e => {
                for(let j = 0; j < lis.length; j++) {
                    lis[j].classList.remove('on')
                }
                lis[i].classList.add('on')
            })
        }

        

        const ui = (function(){

            function hoho() {
                return 1
            }

            return {
                hoho: hoho
            }

        })()

        console.log( ui.hoho() )

        


    </script>


    1. 공통 - 자기소개 해보세요.
    안녕하세요. 한국일보 프론트엔드 직무에 지원한 이종환입니다.
    저는 웹에이전시에서 8년간 근무한 경험이 있고 그 중 대부분은 신한카드의 신규서비스 구축, 리뉴얼, 인터렉션 등의 업무 였습니다
    인터렉션과 UI구현을 좋아해서 디자이너에서 UI개발자로 직종을 변경 하였고  
    사용자가 사용하기 편한 UI를 개발하는 것에 자부심과 책임을 느끼며
    서비스의 질은 좋은 협업에서 나온다고 생각하고 있기 때문에 다른 팀과 소통에 노력하는 편입니다 
    
    그리고 그걸 위해서 인강으로 개인공부를 꾸준히 하고 있습니다

    
    1. 자신의 강점과 약점은 무엇인가요?
    저의 강점은 새로운 기술에 대한 열린 마음과 적극적인 학습 태도입니다. 또한, 문제 해결 능력과 논리적 사고 능력도 강점 중 하나입니다. 
    반면에 제 약점은 디테일한 부분에 대한 주의 부족입니다. 이를 보완하기 위해 더욱 신중하게 작업하고, 팀원들과 함께 코드 리뷰를 진행하는 등의 방법을 사용하고 있습니다.


    1. 지원동기 
    언론사의 주컨텐츠가 고객이 오래머물며 글을 읽는 것이기 때문에 좋은 유아이와 가독성 좋은 웹을 한국일보와 만들어가고 싶어 지원했습니다



    1. 개발자는 웹 개발자도 있고 메타버스 개발자 등 많은데, 어떤 개발자를 선호하나요?
    저는 웹 서비스 개발자를 하고 싶습니다. 



    1. 공통 - 코로나로 비대면 생활을 겪었을텐데 본인만의 노하우가 있나요? 
    비대면 생활에서 저의 노하우는 깃이랑 기술블로그를 통해 노하우를 쌓았습니다? 아 그리고 온라인의 장점인 복습을 열심히 했습니다. 



    1. 본인의 직업관을 말씀해주세요. 
    상호 신뢰와 배려.
    작은 것도 최선을 다해서.
    내가 만든 것이 누군가에게 도움이 되었으면 좋겠습니다


    1. 가치관 - 실패경험에 빗대어
    상호존중과 배려. 
    디자인 전공이기 때문에 팀 프로젝트가 많았는데 제가 군대갔다가 일을해서 늦게 다니다보니 나이가 많아 팀장을 많이 맡게되었습니다 
    대학때는 각자 다른 애들이 모여 하기싫은 애들도 있고 열심히 하는 애들도 있었는데 
    팀웍을 처음에는 실패해서 학점이 망했던 경우도 있었지만 ...   


    1. 인생관 
    남에게 피해주지 말고 순간을 소중히 생각하자


    1. 실패했거나 힘든경험 


    1. 회사 입사 후 포부 말고 본인이 원하는 어떤 개발자가 되고싶은지?
    내가 만든 것이 누군가에게 도움이 되었으면 좋겠습니다
    


    (공통) 회사를 선택하게 될 때, 회사를 볼 때 질문하고 싶은 것은? 질문 잘 하는 것도 능력입니다.



    한국일보는 어떤 느낌?
    객관적이고 어느 한쪽에도 편향되지 않는 기업같습니다.



    작업하며 어려웠던 부분 말해보세요
    1. 프론트 백 다름에 따른 CORS에러.
    2. 캐시 보낼때 axios CORS에러.
    3. 배포 후 CORS에러. 
    4. 백엔드 데이터와 프론트의 date가 다른 이슈  
    5. 리액트의 생명주기에 따라 다시 구현해야하는 UI 
    6. 로그인 회원가입 인증 이슈 


    개발자로서 중요한 역량이 뭐라고 생각하세요? 
    1. 소통 
    2. 문제 해결 능력
    



    왜 하필 언론사인가요? 개발자로서 많은 IT 기업들이 있는데..


    목표 ? 


    12. 공통 - 마지막으로 할 말 있으면 하세요. 
    기회 주신 한국일보께 감사드리고 차분하게 질문주신 면접관님들께도 감사인사 드리고 싶습니다.





    RESTful API에 대해 설명해주세요.
RESTful API는 HTTP 프로토콜을 기반으로하는 웹 서비스 아키텍처입니다. 자원, 메소드, 메시지 등을 정의하여 클라이언트-서버 간의 통신을 가능하게 합니다. 또한, RESTful API는 표준 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 서버와 통신합니다

그렇다면 HTTP 메소드에 대한 설명도 해주실 수 있나요?
GET: 서버에서 리소스(데이터)를 요청하는 메소드입니다. 요청한 데이터를 가져와 응답합니다.
POST: 서버에 데이터를 전송하는 메소드입니다. 데이터를 전송하여 서버에서 처리하고, 처리 결과를 응답합니다.
PUT: 서버에 데이터를 업데이트하는 메소드입니다. 요청한 데이터를 서버에 저장하고, 처리 결과를 응답합니다.
DELETE: 서버에서 데이터를 삭제하는 메소드입니다. 요청한 데이터를 서버에서 삭제하고, 처리 결과를 응답합니다.


CSRF나 XSS 공격을 막는 방법은?
CSRF 공격을 막기 위해서는 서버에서 CSRF Token을 생성하여 세션에 저장하고, 프론트엔드에서 요청 시 해당 Token을 함께 전송하여 인증합니다. SameSite 속성을 쿠키에 설정하여 도메인이 다른 사이트에서는 쿠키를 사용할 수 없도록 제한하는 방법도 있습니다. XSS 공격을 막기 위해서는 입력 값들을 유효성 검증하고, 특수문자들을 제외하는 정규식을 통해서 제거합니다. 또, 서버에서 CSP(Content-Security-Policy)정책을 설정하여, 허용된 스크립트만 실행되도록 제한 할 수도 있습니다. 마지막으로, HTTP 대신에 신뢰할 수 있는 HTTPS를 사용하여 통신 프로토콜을 암호화할 수 있습니다.


async/await에 대해 설명해보세요.
async/await는 비동기적인 작업을 처리할 수 있는 ES2017 문법 입니다. async 함수를 정의하면 함수 내부에서 await 키워드를 이용하여 비동기적으로 처리되는 작업이 완료될 때까지 기다린 후, 결과값을 반환하는 처리를 할 수 있습니다. async/await는 Promise를 기반으로 하며, 코드를 보다 간결하고 직관적으로 작성할 수 있도록 해줍니다. async 함수는 항상 Promise 객체를 반환하며, await 키워드를 이용하여 비동기 처리 결과를 기다립니다.

호이스팅에 대해 설명해보세요.
호이스팅은 변수와 함수 선언이 스코프(scope)의 최상단으로 올려져 실행되는 것을 의미합니다. 이로 인해 선언 전에 사용하는 경우 오류가 발생할 수 있습니다.

-> 변수 선언의 3단계인 선언, 초기화, 할당 순서에 대해서 머릿 속에서 그리고 스스로 대답 해보세요.



클로저란 무엇인가요?
함수가 선언될 때 자동으로 생성되는 렉시컬 환경에 대한 설명입니다. 이러한 렉시컬 환경은 스코프 체인(scope chain)을 형성하게 되는데, 스코프 체인은 함수가 선언될 때의 모든 변수와 함수를 포함하는 렉시컬 스코프(lexical scope)를 형성합니다. 외부 함수가 실행 되고 반환된 후에도 외부 함수의 범위 내의 함수에 체이닝을 할 수 있는 함수 입니다. 정보를 은닉하기 위해서 주로 사용 합니다.



이벤트 버블링에 대해서 설명해주세요.
이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, 상위 요소로 이벤트가 전파되는 현상을 말합니다. 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 장점이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 이벤트 위임 처리를 할 수 있습니다. 버블링 및 캡쳐링을 방지하기 위해서는 이벤트 객체의 stopPropagation() 메서드를 사용하여 이벤트 전파를 중지시키거나, 이벤트 핸들러에서 이벤트가 발생한 요소를 확인하여 처리해야 합니



TDD란 무엇인가요?
TDD(Test-Driven Development)는 테스트 주도 개발 방법론의 준말로, 개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법입니다. TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움이 됩니다. 또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움을 줍니다.




Static Site Generator에 대해서 아시나요?
Static Site Generator(SSG)는 정적인 HTML, CSS, JavaScript 파일을 생성하는 소프트웨어입니다. SSG를 사용하면 동적인 서버 측 프로그래밍 없이 정적인 웹 페이지를 생성할 수 있습니다. 이에 대한 몇 가지 장점은 다음과 같습니다. 정적인 파일을 생성하기 때문에, 웹 서버의 보안에 대한 걱정이 줄어듭니다. 정적인 파일은 웹 브라우저에 의해 더 빠르게 다운로드됩니다. 따라서 로딩 속도가 향상되며 사용자 경험이 좋아집니다. GatsbyJS, Next.js, Hugo, Jekyll 등과 같은 플랫폼들이 있습니다.


Flex와 Grid의 차이점에 대해서 설명해보세요.
Flex는 주로 단일 축 방향의 레이아웃을 구성하는 데 사용되며, 주로 수평 방향으로 레이아웃을 정렬합니다. Grid는 2차원 그리드 시스템을 구성하는 데 사용되며, 수평과 수직 방향으로 모두 레이아웃을 정렬할 수 있습니다. Flex는 아이템들의 크기가 자유로워 유동적으로 변할 수 있습니다. 반면에 Grid는 아이템들의 크기를 미리 정의하여 각 셀의 크기를 일정하게 유지합니다. Flex는 유동적인 레이아웃 변화를 구성하기 적합합니다. 반면에 Grid는 미리 정의된 2차원 그리드 구조를 유지하기 때문에 레이아웃 변화가 적은 경우에 적합합니다.

-> 언제 Flex를 쓰고 언제 Grid를 쓸지에 대해 아는 것이 가장 중요합니다.



비동기 함수에 대해서 설명해 보세요.
비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환합니다. 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며, Promise 객체는 비동기 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 객체입니다. 비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용합니다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요합니다. 여러개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어됩니다.
</body>
</html>